---
layout: post
title: The use of IDisposable and finalizers
date: '2008-02-28T06:50:00.000-08:00'
author: Gert Lombard
tags:
- .net gc
modified_time: '2013-02-10T12:09:27.529-08:00'
blogger_id: tag:blogger.com,1999:blog-1583243090910089198.post-9054600002096807061
blogger_orig_url: http://www.lombard.me/2008/02/the-use-of-idisposable-and-finalizers.html
---

An explanation of how the Garbage Collector handles <code>IDisposable</code> and finalizers.<br /><br />At my work we have lots of code like this in our ASP.NET apps:<br /> <pre name="code" class="c-sharp"><code>class LogonPage : IDisposable<br />{<br />    public LogonPage()<br />    {<br />    }<br />    <br />    ~LogonPage()<br />    {<br />        this.Dispose();<br />    }<br />    <br />    public void Dispose()<br />    {<br />    }<br />    <br />    // rest of code here<br />}</code></pre> <br />In other words, a class that implements <code>IDisposable</code> with an empty <code>Dispose</code> method and a finalizer (aka destructor) that calls <code>Dispose</code>.<br /><br />The intention of this code appears to be to somehow give a "hint" to the Garbage Collector to free the memory associated with this object when the "destructor" is called.<br /><br />Implementing a finalizer in this case has no benefit at all, in fact, it probably has the opposite effect of what was expected.&nbsp; It will not cause the GC to free the object's memory any earilier than an object not implementing a finalizer and it places additional load on the GC.<br /><br />There are two problems with the assumption that implementing <code>IDisposable</code> and a finalizer will somehow affect the GC to free the memory earlier:<br /><br />1. C# finalizers are not deterministic;<br /><br />2. Objects with finalizers are kept in memory longer than objects without and require additional GC processing.<br /><br /><strong>Non-determistic finalization</strong><br /><br />It is a common misconception that a C# destructor is similar to a C++ destructor.&nbsp; In C# the "~" method is often called a destructor, but that's a misnomer.&nbsp; It's not a destructor in the C++ sense.&nbsp; Instead the "~" method is really just an override for <code>Object.Finalize()</code>.&nbsp; It was a mistake of the .NET implementors to even use the "~" character to indicate a finalizer.<br /><br />In C++ the destructor is deterministic, in other words, the developer is responsible for allocating and freeing memory and destructor is called at an exact predictable time: e.g. when an object on the stack reaches the end of its lifetime (i.e. when it leaves the scope of the code block) or when an object on the heap is explicitly freed with the <code>delete</code> keyword.<br /><br />But .NET finalization is "non-deterministic".&nbsp; That means you don't know when and in what order the GC will call the finalizers and you have no control over when the object will be freed.&nbsp; Unlike with C++ destructors, the programmer has no way of explicitly calling a .NET finalizer.<br /><br /><strong>Generations and finalization</strong><br /><br />The .NET GC uses a generational algorithm.&nbsp; This means the GC divides the managed heap in three logical sections, or generations, called gen 0, gen 1 and gen 2.&nbsp; Each of these generations have a maximum size, initially 256kb, 2MB and 10MB respectively. New objects are usually allocated on gen 0.<br /><br />When a new object is allocated and the gen 0 memory is too full to accomodate the new object, the GC will reclaim the memory allocated to unreachable objects by compacting the gen 0 memory.&nbsp; Next the GC promotes all gen 0 objects to gen 1.&nbsp; This empties gen 0 for new objects.<br /><br />Similarly when the gen 1 heap becomes full, the GC reclaims unused memory and promotes the gen 1 objects to gen 2.<br /><br />The GC performs collection more frequently on lower generations than higher generations.<br /><br />The GC frees finalizable objects much later than those wihout finalizers.<br /><br />When a finalizable object is created, a reference to it is added to the "finalization list".&nbsp; When the GC determines that an object is no longer reachable, but it's in the finalization list, it's not freed immediately.&nbsp; Instead the finalizable object is put on another special queue called the "f-reachable queue" and promoted to the next generation.&nbsp; A special thread called the "finalizer thread" monitors the f-reachable queue and calls the finalizers when necessary.&nbsp; These objects will eventually be freed the next time a gen 1 or 2 garbage collection is performed.&nbsp; Therefore it takes at least two garbage collection cycles to free finalizable objects.<br /><br /><strong>Recommended IDispoable pattern</strong><br /><br />Implementing <code>IDisposable.Dispose</code> has no effect on the GC at all.&nbsp; It's little more than just a standard interface for providing a "Close" method on your class to allow the user to close/unload resources.<br /><br />Use the following "Dispose pattern" when your class uses other managed classes that implement <code>IDisposable</code> (note a finalizer is <em>not</em> needed here).&nbsp; This is the most common scenario.<br /><pre><code>class MyClass : IDisposable <br />{<br />    private bool disposed = false;<br />    private FileStream file;<br />    <br />    public MyClass()<br />    {<br />        file = new FileStream(...);<br />    }<br />    <br />    public void Dispose()<br />    {<br />        if (!disposed)<br />        {<br />            file.Close();<br />            disposed = true;<br />        }<br />    }<br />    <br />    public void Close()<br />    {<br />        Dispose();<br />    }<br />}</code></pre><br />If you have to implement <code>IDisposable</code> and a finalizer, use the recommended pattern as described in MSDN.<br /><pre><code>class MyClass : IDisposable <br />{<br />    private bool disposed = false;<br />    private IntPtr file = IntPtr.Zero; // Unmanaged resource<br />    <br />    public MyClass()<br />    {<br />        file = ...; // allocate unmanaged resource<br />    }<br />    <br />    ~MyClass()<br />    {<br />        Dispose(false);<br />    }<br />    <br />    public void Dispose()<br />    {<br />        Dispose(true);<br />        GC.SuppressFinalize(this);<br />    }<br />    <br />    public void Close()<br />    {<br />        Dispose();<br />    }<br />    <br />    protected virtual void Dispose(bool disposing)<br />    {<br />        if (!disposed)<br />        {<br />            if (disposing)<br />            {<br />                // dispose managed resources<br />            }<br />            if (file != IntPtr.Zero)<br />            {<br />                // free unmanaged resource<br />                file = IntPtr.Zero;<br />            }<br />            disposed = true;<br />        }<br />    }<br />}</code></pre><br /><strong>Summary</strong><br /><br />Only implement <code>IDisposable</code> if you have a reason to do so, e.g. if your class has member fields that implement <code>IDisposable</code> so you need to provide a <code>Dispose</code> method call <code>Dispose</code> on the member fields.<br /><br />The simplest guideline regarding the use of finalizers is: <em>don't use it at all</em> unless your class directly wraps unmanaged resources (such as a native file handle) and you want to make sure that <code>Dispose</code> gets called at some point, which really almost never happens in a typical ASP.NET application.&nbsp; Don't create empty finalizers.<br /><br />A class implementing <code>IDisposable</code> doesn't always require a finalizer, but a class that implements a finalizer should always implement <code>IDisposable</code>.<br /><br />This was just my interpretation of the GC process.&nbsp; For a more complete and accurate description, see Jeffrey Richter's book "CLR via C#".<br /><br />Also see:<br /><ul><br /><li><a href="http://msdn.microsoft.com/msdnmag/issues/04/05/NETMatters/">.NET Matters: Finalizers, Assembly Names, MethodInfo, and More</a></li><br /><li><a href="http://dn.codegear.com/article/29365">Object Destructors and Finalizers in .NET Using C# and Delphi for .NET</a></li><br /><li><a href="http://www.devx.com/dotnet/Article/33167/0/page/1">When and How to Use Dispose and Finalize in C#</a></li></ul>