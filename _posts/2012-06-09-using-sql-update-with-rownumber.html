---
layout: post
title: Using SQL UPDATE with ROW_NUMBER()
date: '2012-06-09T10:21:00.000-07:00'
author: Gert Lombard
tags:
- SQL
modified_time: '2013-03-11T09:38:31.303-07:00'
blogger_id: tag:blogger.com,1999:blog-1583243090910089198.post-9055969702512049647
blogger_orig_url: http://www.lombard.me/2012/06/using-sql-update-with-rownumber.html
---

<p><strong><u>The problem:</u></strong></p> <p>The application is displaying a list of “To-do” tasks from a SQL Server database table, but the rows are currently displayed in an arbitrary order which is not necessarily in the order the user wants them to be displayed. We want to add a new feature to the application to allow the user to specify the order of the To-do items in the list (i.e. a priority for each To-do item).</p> <p>We want to introduce a new “sort order” (or sequence number) column to the table to allow the user to specify the order in which the rows are to be displayed.</p> <p>Adding a new column to the “create table” script (for new databases) is obviously straightforward.&nbsp; But the problem is that we also need to be able to upgrade (migrate) existing customers to the new table structure.</p> <p>Therefore we need to create a SQL migration script to add a new priority / sort-order column to the existing Todo table.</p> <p>Currently the Todo table structure looks like this:</p><pre><code>create table Todo<br />(<br />	TodoId bigint not null primary key identity,<br />	Priority nvarchar(10) not null,<br />	Title nvarchar(200) not null,<br />	DateDone datetime null<br />)</code></pre><br /><p>The following query used by the application to retrieve the Todo list illustrates the problem:</p><pre><code>select * from Todo order by Priority</code></pre><br /><p>Result:</p><br /><table cellspacing="0" cellpadding="2" border="1"><br /><tbody><br /><tr><br /><td valign="top"><strong>TodoId</strong></td><br /><td valign="top"><strong>Priority</strong></td><br /><td valign="top"><strong>Title</strong></td><br /><td valign="top"><strong>DateDone</strong></td></tr><br /><tr><br /><td valign="top" width="84">4</td><br /><td valign="top" width="88">High</td><br /><td valign="top" width="220">Call Joe</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">2</td><br /><td valign="top" width="88">High</td><br /><td valign="top" width="220">Backup computer</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">3</td><br /><td valign="top" width="88">Low</td><br /><td valign="top" width="220">Wash car</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">5</td><br /><td valign="top" width="88">Low</td><br /><td valign="top" width="220">Mow the lawn</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">6</td><br /><td valign="top" width="88">Low</td><br /><td valign="top" width="220">Groceries</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">7</td><br /><td valign="top" width="88">Medium</td><br /><td valign="top" width="220">Pick up package at post office</td><br /><td valign="top" width="99">NULL</td></tr><br /><tr><br /><td valign="top" width="84">1</td><br /><td valign="top" width="88">Medium</td><br /><td valign="top" width="220">Take the dog for a walk</td><br /><td valign="top" width="99">NULL</td></tr></tbody></table><br /><p>Notice above that the first two ‘High’ priority items are shown in an arbitrary order.&nbsp; We may want to order it by the “TodoId” column which is perhaps slightly better, but still not necessarily in the order the user wants to see the tasks.</p><br /><p><strong><u>The solution:</u></strong></p><br /><p>We have to produce two SQL scripts: one is the script used for new installations, the second is to upgrade/migrate existing databases to the new structure.</p><br /><p>The first part is easy: for new installation script we just add the new column:</p><pre>sortOrder int not null</pre><br /><p>But in the migration script for existing databases, we initially have to add the new “sortOrder” column as a nullable field since there are already rows in the table and we need to provide reasonable initial/default value for the new column first.&nbsp; So we first add the column as a nullable, and we’ll alter the table afterwards to make it ‘not null’.</p><br /><p>So the first step in the migration script is to add the new field to the existing Todo table:</p><pre><code>alter table Todo add sortOrder int null</code></pre><br /><p>Now we need to update the Todo table to provide an appropriate initial value for the new sortOrder field in each row.</p><br /><p>Our Todo tasks are priortised as ‘High’, ‘Medium’ or ‘Low’.&nbsp; We want the sortOrder value to start from 1 and increment for each subsequent row within each of these 3 priorties.&nbsp; In other words, we want the two ‘High’ priority tasks to be given a sortOrder value of 1 and 2, the same for the two ‘Medium’ tasks, and the three ‘Low’ priority tasks need to be given a sortOrder of 1, 2, and 3.</p><br /><p>The trick is to use the SQL UPDATE statement together the SQL Server ROW_NUMBER() function.</p><br /><p>First, let’s just select the data using the ROW_NUMBER() function to see how we can get an appropriate initial value for sortOrder for each row:</p><pre><code>select TodoId, Priority, Title,<br />	ROW_NUMBER() over(partition by Priority order by TodoId) as rowIndex<br />	from Todo<br />	order by Priority, rowIndex</code></pre><br /><p>Result:</p><br /><table cellspacing="0" cellpadding="2" border="1"><br /><tbody><br /><tr><br /><td valign="top" width="100"><strong>TodoId</strong></td><br /><td valign="top" width="84"><strong>Priority</strong></td><br /><td valign="top" width="237"><strong>Title</strong></td><br /><td valign="top" width="81"><strong>rowIndex</strong></td></tr><br /><tr><br /><td valign="top" width="100">2</td><br /><td valign="top" width="84">High</td><br /><td valign="top" width="237">Backup computer</td><br /><td valign="top" width="81">1</td></tr><br /><tr><br /><td valign="top" width="100">4</td><br /><td valign="top" width="84">High</td><br /><td valign="top" width="237">Call Joe</td><br /><td valign="top" width="81">2</td></tr><br /><tr><br /><td valign="top" width="100">3</td><br /><td valign="top" width="84">Low</td><br /><td valign="top" width="237">Wash car</td><br /><td valign="top" width="81">1</td></tr><br /><tr><br /><td valign="top" width="100">5</td><br /><td valign="top" width="84">Low</td><br /><td valign="top" width="237">Mow the lawn</td><br /><td valign="top" width="81">2</td></tr><br /><tr><br /><td valign="top" width="100">6</td><br /><td valign="top" width="84">Low</td><br /><td valign="top" width="237">Groceries</td><br /><td valign="top" width="81">3</td></tr><br /><tr><br /><td valign="top" width="100">1</td><br /><td valign="top" width="84">Medium</td><br /><td valign="top" width="237">Take the dog for a walk</td><br /><td valign="top" width="81">1</td></tr><br /><tr><br /><td valign="top" width="100">7</td><br /><td valign="top" width="84">Medium</td><br /><td valign="top" width="237">Pick up package at post office</td><br /><td valign="top" width="81">2</td></tr></tbody></table><br /><p>The “rowIndex” value in the result above gives us the correct value we’d like to update the new sortOrder column with for each row.</p><br /><p>Now we need to combine this query with a SQL UPDATE statement to update sortOrder:</p><pre><code>update t<br />	set sortOrder = rowIndex<br />from<br />(<br />	select sortOrder, ROW_NUMBER() over(partition by Priority order by TodoId) as rowIndex<br />	from Todo<br />	where sortOrder is null<br />) as t</code></pre><br /><p>Now “sortOrder” has the desired values partitioned by priority.</p><br /><p>The last step is just to make the sortOrder column not null:</p><pre><code>alter table Todo alter column sortOrder int not null</code></pre><br /><p>Also see:</p><br /><ul><br /><li><a href="http://stackoverflow.com/questions/5686058/how-to-use-row-number-in-sql-server">How to use row_number() in SQL Server</a> (StackOverflow)</li></ul>  