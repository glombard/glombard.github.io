---
layout: post
title: Good development team practices
date: '2013-10-02T08:44:00.000-07:00'
author: Gert Lombard
tags:
- agile
- teams
modified_time: '2013-10-03T05:16:10.416-07:00'
blogger_id: tag:blogger.com,1999:blog-1583243090910089198.post-8319037658006247017
blogger_orig_url: http://www.lombard.me/2013/10/good-development-team-practices.html
---

Some good software development practices:<br /><br /><b>Automate everything.</b><br /><br />It often takes much longer to automate a small task than just doing it manually. I don't know about you, but I hate doing the same mundane task over and over. I admit, it's sometimes possible to take it too far as well. Yesterday I easily spent at least 30 minutes creating a single line <a href="http://curl.haxx.se/">cURL</a> command for downloading JDK 1.4 from the Oracle Archive Download site.<br /><br />Automation also serves as documentation. When you write the steps for installing some utility in a script, then you don't need to explain to another developer later what needs to be installed. Just read the script to see what's needed.<br /><br />Remember that there are lots of existing tools to help automating things, like <a href="http://nuget.org/">NuGet</a> and&nbsp;<a href="http://chocolatey.org/">Chocolatey</a>.<br /><br />Consider choosing a standard scripting tool like PowerShell or Python for everyone in the team to use. You can do a lot with just plain old batch files too.<br /><br />At a very minimum, please, please don't do your builds manually! For builds/compiling your code, you obviously need to use something Jenkins, TeamCity or TFS. Even in very small teams you should do automated builds / continuous integration.<br /><br /><b>Test everything.</b><br /><br />If you're not already doing some kind of automated tests, you absolutely have to start. There is no excuse. Automated testing is not something you wait for your QA team to do - it's a development task.<br /><br />Unit tests are possible even with legacy code. At least start writing any new code in a testable way and build your tests up over time.<br /><br />Integration tests should be possible for most projects. In .NET with WPF, start using Microsoft's Coded UI tests. It's a very easy way to automate your WPF UI. If you're using ASP.NET, then you'll want to use <a href="http://watin.org/">WatiN</a>.<br /><br />Just don't get too religious about testing and code coverage and forget what you're actually trying to accomplish. Sometimes we spend ages unit testing something of pretty low value, while the actual problem areas aren't covered well.&nbsp;There's no point in having 100% code coverage when you don't have&nbsp;enough&nbsp;tests to prove that you've met the acceptance criteria.<br /><br /><b>Follow good check-in/commit etiquette.</b><br /><br /><a href="http://www.codinghorror.com/blog/2008/08/check-in-early-check-in-often.html">Commit often</a> in small chunks. Pull / Get Latest often. This makes it easier for yourself because you reduce the number of conflicts to deal with.<br /><br />Use good comments for your commit messages, not just something vague like "fix".<br /><br />When merging conflicts, be considerate. Don't just throw away someone else's changes because you're too lazy to carefully merge your changes. If you can't tell what's going on and a merge isn't feasible, be considerate and take the server version then carefully put your bits back again.<br /><br /><b>Keep learning.</b><br /><br />Encourage individuals to stay up to date with the continuous changes in technology. Follow famous developers on Twitter and Google+. If you don't know where to start, just follow one famous person you know and go from there. For .NET, follow Scott Hanselman on Twitter and/or Google+.<br /><br />As a team, make time to learn together by: (a) trying new things, (b) doing Patterns &amp; Practices meetings, (c) doing informal "show and tell" presentations. Encourage the team to work on side-projects when you have a spare moment now and then.<br /><br /><strong>Maximize savings / Eliminate waste.</strong><br /><br />Remember why we're working here. We're not here to have fun, to learn, to write unit tests or even to write code. We're here to solve business problems. Bottom line: to make the business money. (But yes, of course we want to have fun and learn while solving the real business problems.)<br /><br />Before you write that cool ORM (or CSV parser or some other way to reinvent the wheel), ask yourself: are we in the business of writing ORMs (or CSV parsers etc)? If a perfectly good&nbsp;open source or commercial solution already exists, then don't reinvent the wheel. I love reinventing the wheel myself, I know how much fun it can be to write libraries that you imagine might be usable by someone else, but use your time wisely.<br /><br />The same goes for other things that costs the company money. Don't waste printer ink &amp;&nbsp;paper! Why are you still printing articles for reading?&nbsp;(or even worse, printing source code!?) Learn to read on a screen. Or buy a Kindle if you claim you don't like reading a computer monitor or tablet. Use Pocket or Instapaper to save articles for later reading on a suitable device.<br /><br /><b>Always look for improvements.</b><br /><br />I often hear a colleague say something like "<i>But &nbsp;that's not Agile/Scrum!</i>", then my response is "<i>We call it Agile because the process itself is agile.</i>" Don't treat your processes/methodologies like a religion. Change things that don't work and do more of what works well. Have regular retrospectives and follow up on improvement actions identified. An exception would be when you're starting with a new process like Scrum: first follow the rules strictly (do "Scrum by the book"), then only tweak your process at the end of each sprint according to issues raised in the retrospective.<br /><br /><strong>Use the team's strengths.</strong><br /><br />Avoid specialization, but know your team's strengths (and weaknesses).&nbsp;Consider&nbsp;team members'&nbsp;interests. People who work on something they find interesting will generally be more happy and more productive. Consider what's the best use of everyone's time. For example, does it make sense for the most senior team member to perform the team's admin (sprint reports, keeping documentation up to date for CMMI, etc)?&nbsp; Does it make sense for the most junior team member to spend a week figuring out how to install the new TFS server when another member could do it in an hour? It's important to let everyone work in as many areas of the project as possible to distribute the knowledge as much as possible, but there's a balance to keep.<br /><br /><strong>Be pragmatic.</strong><br /><br />Don't be scared to go outside of your comfort zone to use the right tool for the job. For example, if you just spent half the day searching for a Markdown to PDF converter, and the only good solution you could find is a Ruby &amp; Linux-based solution, then don't disqualify it just because your team only has experience using Windows.<br /><br />